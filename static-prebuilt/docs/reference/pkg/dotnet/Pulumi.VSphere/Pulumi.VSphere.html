<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Namespace Pulumi.VSphere
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Namespace Pulumi.VSphere
   ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="/docs/reference/pkg/dotnet/" style="margin-top: 5px">
                <img id="logo" class="svg" src="../logo.svg" alt="" style="height:40px">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Pulumi.VSphere">
  
  <h1 id="Pulumi_VSphere" data-uid="Pulumi.VSphere" class="text-break">Namespace Pulumi.VSphere
  </h1>
  <div class="markdown level0 summary"></div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h3 id="classes">Classes
  </h3>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeCluster.html">ComputeCluster</a></h4>
      <section><blockquote>
<p><strong>A note on the naming of this resource:</strong> VMware refers to clusters of
hosts in the UI and documentation as <em>clusters</em>, <em>HA clusters</em>, or <em>DRS
clusters</em>. All of these refer to the same kind of resource (with the latter two
referring to specific features of clustering). We use
<code>vsphere..ComputeCluster</code> to differentiate host clusters from <em>datastore
clusters</em>, which are clusters of datastores that can be used to distribute load
and ensure fault tolerance via distribution of virtual machines. Datastore
clusters can also be managed through the provider, via the
<code>vsphere..DatastoreCluster</code> resource.</p>
</blockquote>
<p>The <code>vsphere..ComputeCluster</code> resource can be used to create and manage
clusters of hosts allowing for resource control of compute resources, load
balancing through DRS, and high availability through vSphere HA.</p>
<p>For more information on vSphere clusters and DRS, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-8ACF3502-5314-469F-8CC9-4A9BD5925BC2.html">this
page</a>. For more information on vSphere HA, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.avail.doc/GUID-5432CA24-14F1-44E3-87FB-61D937831CF6.html">this
page</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
<h2 id="vsphere-version-requirements">vSphere Version Requirements</h2>
<p>A large number of settings in the <code>vsphere..ComputeCluster</code> resource require a
specific version of vSphere to function. Rather than include warnings at every
setting or section, these settings are documented below.  Note that this list
is for cluster-specific attributes only, and does not include the
<code>tags</code> parameter, which requires vSphere 6.0 or higher across all
resources that can be tagged.</p>
<p>All settings are footnoted by an asterisk (<code>*</code>) in their specific section in
the documentation, which takes you here.</p>
<h3 id="settings-that-require-vsphere-version-60-or-higher">Settings that require vSphere version 6.0 or higher</h3>
<p>These settings require vSphere 6.0 or higher:</p>
<ul>
<li><code>ha_datastore_apd_recovery_action</code></li>
<li><code>ha_datastore_apd_response</code></li>
<li><code>ha_datastore_apd_response_delay</code></li>
<li><code>ha_datastore_pdl_response</code></li>
<li><code>ha_vm_component_protection</code></li>
</ul>
<h3 id="settings-that-require-vsphere-version-65-or-higher">Settings that require vSphere version 6.5 or higher</h3>
<p>These settings require vSphere 6.5 or higher:</p>
<ul>
<li><code>drs_enable_predictive_drs</code></li>
<li><code>ha_admission_control_host_failure_tolerance</code>
(When <code>ha_admission_control_policy</code> is set to
<code>resourcePercentage</code> or <code>slotPolicy</code>. Permitted in all versions under
<code>failoverHosts</code>)</li>
<li><code>ha_admission_control_resource_percentage_auto_compute</code></li>
<li><code>ha_vm_restart_timeout</code></li>
<li><code>ha_vm_dependency_restart_condition</code></li>
<li><code>ha_vm_restart_additional_delay</code></li>
<li><code>proactive_ha_automation_level</code></li>
<li><code>proactive_ha_enabled</code></li>
<li><code>proactive_ha_moderate_remediation</code></li>
<li><code>proactive_ha_provider_ids</code></li>
<li><code>proactive_ha_severe_remediation</code></li>
</ul>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterArgs.html">ComputeClusterArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterHostGroup.html">ComputeClusterHostGroup</a></h4>
      <section><p>The <code>vsphere..ComputeClusterHostGroup</code> resource can be used to manage groups
of hosts in a cluster, either created by the
<code>vsphere..ComputeCluster</code> resource or looked up
by the <code>vsphere..ComputeCluster</code> data source.</p>
<p>This resource mainly serves as an input to the
<code>vsphere..ComputeClusterVmHostRule</code>
resource - see the documentation for that resource for further details on how
to use host groups.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterHostGroupArgs.html">ComputeClusterHostGroupArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterHostGroupState.html">ComputeClusterHostGroupState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterState.html">ComputeClusterState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmAffinityRule.html">ComputeClusterVmAffinityRule</a></h4>
      <section><p>The <code>vsphere..ComputeClusterVmAffinityRule</code> resource can be used to manage
VM affinity rules in a cluster, either created by the
<code>vsphere..ComputeCluster</code> resource or looked up
by the <code>vsphere..ComputeCluster</code> data source.</p>
<p>This rule can be used to tell a set to virtual machines to run together on a
single host within a cluster. When configured, DRS will make a best effort to
ensure that the virtual machines run on the same host, or prevent any operation
that would keep that from happening, depending on the value of the
<code>mandatory</code> flag.</p>
<blockquote>
<p>Keep in mind that this rule can only be used to tell VMs to run together on
a <em>non-specific</em> host - it can't be used to pin VMs to a host. For that, see
the
<code>vsphere..ComputeClusterVmHostRule</code>
resource.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using System.Collections.Generic;
using System.Linq;
using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm = new List&amp;lt;VSphere.VirtualMachine&gt;();
    for (var rangeIndex = 0; rangeIndex &amp;lt; 2; rangeIndex++)
    {
        var range = new { Value = rangeIndex };
        vm.Add(new VSphere.VirtualMachine($&amp;quot;vm-{range.Value}&amp;quot;, new VSphere.VirtualMachineArgs
        {
            DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
            Disks = 
            {
                new VSphere.Inputs.VirtualMachineDiskArgs
                {
                    Label = &amp;quot;disk0&amp;quot;,
                    Size = 20,
                },
            },
            GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
            Memory = 2048,
            NetworkInterfaces = 
            {
                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
                {
                    NetworkId = network.Apply(network =&gt; network.Id),
                },
            },
            NumCpus = 2,
            ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
        }));
    }
    var clusterVmAffinityRule = new VSphere.ComputeClusterVmAffinityRule(&amp;quot;clusterVmAffinityRule&amp;quot;, new VSphere.ComputeClusterVmAffinityRuleArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        VirtualMachineIds = vm.Select(__item =&gt; __item.Id).ToList(),
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmAffinityRuleArgs.html">ComputeClusterVmAffinityRuleArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmAffinityRuleState.html">ComputeClusterVmAffinityRuleState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmAntiAffinityRule.html">ComputeClusterVmAntiAffinityRule</a></h4>
      <section><p>The <code>vsphere..ComputeClusterVmAntiAffinityRule</code> resource can be used to
manage VM anti-affinity rules in a cluster, either created by the
<code>vsphere..ComputeCluster</code> resource or looked up
by the <code>vsphere..ComputeCluster</code> data source.</p>
<p>This rule can be used to tell a set to virtual machines to run on different
hosts within a cluster, useful for preventing single points of failure in
application cluster scenarios. When configured, DRS will make a best effort to
ensure that the virtual machines run on different hosts, or prevent any
operation that would keep that from happening, depending on the value of the
<code>mandatory</code> flag.</p>
<blockquote>
<p>Keep in mind that this rule can only be used to tell VMs to run separately
on <em>non-specific</em> hosts - specific hosts cannot be specified with this rule.
For that, see the
<code>vsphere..ComputeClusterVmHostRule</code>
resource.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using System.Collections.Generic;
using System.Linq;
using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm = new List&amp;lt;VSphere.VirtualMachine&gt;();
    for (var rangeIndex = 0; rangeIndex &amp;lt; 2; rangeIndex++)
    {
        var range = new { Value = rangeIndex };
        vm.Add(new VSphere.VirtualMachine($&amp;quot;vm-{range.Value}&amp;quot;, new VSphere.VirtualMachineArgs
        {
            DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
            Disks = 
            {
                new VSphere.Inputs.VirtualMachineDiskArgs
                {
                    Label = &amp;quot;disk0&amp;quot;,
                    Size = 20,
                },
            },
            GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
            Memory = 2048,
            NetworkInterfaces = 
            {
                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
                {
                    NetworkId = network.Apply(network =&gt; network.Id),
                },
            },
            NumCpus = 2,
            ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
        }));
    }
    var clusterVmAntiAffinityRule = new VSphere.ComputeClusterVmAntiAffinityRule(&amp;quot;clusterVmAntiAffinityRule&amp;quot;, new VSphere.ComputeClusterVmAntiAffinityRuleArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        VirtualMachineIds = vm.Select(__item =&gt; __item.Id).ToList(),
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmAntiAffinityRuleArgs.html">ComputeClusterVmAntiAffinityRuleArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmAntiAffinityRuleState.html">ComputeClusterVmAntiAffinityRuleState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmDependencyRule.html">ComputeClusterVmDependencyRule</a></h4>
      <section><p>The <code>vsphere..ComputeClusterVmDependencyRule</code> resource can be used to manage
VM dependency rules in a cluster, either created by the
<code>vsphere..ComputeCluster</code> resource or looked up
by the <code>vsphere..ComputeCluster</code> data source.</p>
<p>A virtual machine dependency rule applies to vSphere HA, and allows
user-defined startup orders for virtual machines in the case of host failure.
Virtual machines are supplied via groups, which can be managed via the
<code>vsphere..ComputeClusterVmGroup</code>
resource.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm1 = new VSphere.VirtualMachine(&amp;quot;vm1&amp;quot;, new VSphere.VirtualMachineArgs
    {
        DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
        Disks = 
        {
            new VSphere.Inputs.VirtualMachineDiskArgs
            {
                Label = &amp;quot;disk0&amp;quot;,
                Size = 20,
            },
        },
        GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
        Memory = 2048,
        NetworkInterfaces = 
        {
            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
            {
                NetworkId = network.Apply(network =&gt; network.Id),
            },
        },
        NumCpus = 2,
        ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
    });
    var vm2 = new VSphere.VirtualMachine(&amp;quot;vm2&amp;quot;, new VSphere.VirtualMachineArgs
    {
        DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
        Disks = 
        {
            new VSphere.Inputs.VirtualMachineDiskArgs
            {
                Label = &amp;quot;disk0&amp;quot;,
                Size = 20,
            },
        },
        GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
        Memory = 2048,
        NetworkInterfaces = 
        {
            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
            {
                NetworkId = network.Apply(network =&gt; network.Id),
            },
        },
        NumCpus = 2,
        ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
    });
    var clusterVmGroup1 = new VSphere.ComputeClusterVmGroup(&amp;quot;clusterVmGroup1&amp;quot;, new VSphere.ComputeClusterVmGroupArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        VirtualMachineIds = 
        {
            vm1.Id,
        },
    });
    var clusterVmGroup2 = new VSphere.ComputeClusterVmGroup(&amp;quot;clusterVmGroup2&amp;quot;, new VSphere.ComputeClusterVmGroupArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        VirtualMachineIds = 
        {
            vm2.Id,
        },
    });
    var clusterVmDependencyRule = new VSphere.ComputeClusterVmDependencyRule(&amp;quot;clusterVmDependencyRule&amp;quot;, new VSphere.ComputeClusterVmDependencyRuleArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        DependencyVmGroupName = clusterVmGroup1.Name,
        VmGroupName = clusterVmGroup2.Name,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmDependencyRuleArgs.html">ComputeClusterVmDependencyRuleArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmDependencyRuleState.html">ComputeClusterVmDependencyRuleState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmGroup.html">ComputeClusterVmGroup</a></h4>
      <section><p>The <code>vsphere..ComputeClusterVmGroup</code> resource can be used to manage groups of
virtual machines in a cluster, either created by the
<a href="/docs/providers/vsphere/r/compute_cluster.html"><code>vsphere..ComputeCluster</code></a> resource or looked up
by the <a href="/docs/providers/vsphere/d/compute_cluster.html"><code>vsphere..ComputeCluster</code></a> data source.</p>
<p>This resource mainly serves as an input to the
<a href="/docs/providers/vsphere/r/compute_cluster_vm_dependency_rule.html"><code>vsphere..ComputeClusterVmDependencyRule</code></a>
and
<a href="/docs/providers/vsphere/r/compute_cluster_vm_host_rule.html"><code>vsphere..ComputeClusterVmHostRule</code></a>
resources. See the individual resource documentation pages for more information.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using System.Collections.Generic;
using System.Linq;
using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm = new List&amp;lt;VSphere.VirtualMachine&gt;();
    for (var rangeIndex = 0; rangeIndex &amp;lt; 2; rangeIndex++)
    {
        var range = new { Value = rangeIndex };
        vm.Add(new VSphere.VirtualMachine($&amp;quot;vm-{range.Value}&amp;quot;, new VSphere.VirtualMachineArgs
        {
            DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
            Disks = 
            {
                new VSphere.Inputs.VirtualMachineDiskArgs
                {
                    Label = &amp;quot;disk0&amp;quot;,
                    Size = 20,
                },
            },
            GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
            Memory = 2048,
            NetworkInterfaces = 
            {
                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
                {
                    NetworkId = network.Apply(network =&gt; network.Id),
                },
            },
            NumCpus = 2,
            ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
        }));
    }
    var clusterVmGroup = new VSphere.ComputeClusterVmGroup(&amp;quot;clusterVmGroup&amp;quot;, new VSphere.ComputeClusterVmGroupArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        VirtualMachineIds = vm.Select(__item =&gt; __item.Id).ToList(),
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmGroupArgs.html">ComputeClusterVmGroupArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmGroupState.html">ComputeClusterVmGroupState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmHostRule.html">ComputeClusterVmHostRule</a></h4>
      <section><p>The <code>vsphere..ComputeClusterVmHostRule</code> resource can be used to manage
VM-to-host rules in a cluster, either created by the
<code>vsphere..ComputeCluster</code> resource or looked up
by the <code>vsphere..ComputeCluster</code> data source.</p>
<p>This resource can create both <em>affinity rules</em>, where virtual machines run on
specified hosts, or <em>anti-affinity</em> rules, where virtual machines run on hosts
outside of the ones specified in the rule. Virtual machines and hosts are
supplied via groups, which can be managed via the
<code>vsphere..ComputeClusterVmGroup</code> and
<code>vsphere..ComputeClusterHostGroup</code>
resources.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var host = dc.Apply(dc =&gt; Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;esxi1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm = new VSphere.VirtualMachine(&amp;quot;vm&amp;quot;, new VSphere.VirtualMachineArgs
    {
        DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
        Disks = 
        {
            new VSphere.Inputs.VirtualMachineDiskArgs
            {
                Label = &amp;quot;disk0&amp;quot;,
                Size = 20,
            },
        },
        GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
        Memory = 2048,
        NetworkInterfaces = 
        {
            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
            {
                NetworkId = network.Apply(network =&gt; network.Id),
            },
        },
        NumCpus = 2,
        ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
    });
    var clusterVmGroup = new VSphere.ComputeClusterVmGroup(&amp;quot;clusterVmGroup&amp;quot;, new VSphere.ComputeClusterVmGroupArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        VirtualMachineIds = 
        {
            vm.Id,
        },
    });
    var clusterHostGroup = new VSphere.ComputeClusterHostGroup(&amp;quot;clusterHostGroup&amp;quot;, new VSphere.ComputeClusterHostGroupArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        HostSystemIds = 
        {
            host.Apply(host =&gt; host.Id),
        },
    });
    var clusterVmHostRule = new VSphere.ComputeClusterVmHostRule(&amp;quot;clusterVmHostRule&amp;quot;, new VSphere.ComputeClusterVmHostRuleArgs
    {
        AffinityHostGroupName = clusterHostGroup.Name,
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        VmGroupName = clusterVmGroup.Name,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmHostRuleArgs.html">ComputeClusterVmHostRuleArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ComputeClusterVmHostRuleState.html">ComputeClusterVmHostRuleState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.Config.html">Config</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ContentLibrary.html">ContentLibrary</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ContentLibraryArgs.html">ContentLibraryArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ContentLibraryItem.html">ContentLibraryItem</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ContentLibraryItemArgs.html">ContentLibraryItemArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ContentLibraryItemState.html">ContentLibraryItemState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ContentLibraryState.html">ContentLibraryState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.CustomAttribute.html">CustomAttribute</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.CustomAttributeArgs.html">CustomAttributeArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.CustomAttributeState.html">CustomAttributeState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.Datacenter.html">Datacenter</a></h4>
      <section><p>Provides a VMware vSphere datacenter resource. This can be used as the primary
container of inventory objects such as hosts and virtual machines.</p>
<h2 id="example-usage">Example Usage</h2>
<h3 id="create-datacenter-on-the-root-folder">Create datacenter on the root folder</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var prodDatacenter = new VSphere.Datacenter(&amp;quot;prodDatacenter&amp;quot;, new VSphere.DatacenterArgs
    {
    });
}

}
</code></pre>
<h3 id="create-datacenter-on-a-subfolder">Create datacenter on a subfolder</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var researchDatacenter = new VSphere.Datacenter(&amp;quot;researchDatacenter&amp;quot;, new VSphere.DatacenterArgs
    {
        Folder = &amp;quot;/research/&amp;quot;,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.DatacenterArgs.html">DatacenterArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DatacenterState.html">DatacenterState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DatastoreCluster.html">DatastoreCluster</a></h4>
      <section><p>The <code>vsphere..DatastoreCluster</code> resource can be used to create and manage
datastore clusters. This can be used to create groups of datastores with a
shared management interface, allowing for resource control and load balancing
through Storage DRS.</p>
<p>For more information on vSphere datastore clusters and Storage DRS, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-598DF695-107E-406B-9C95-0AF961FC227A.html">this
page</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> Storage DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.DatastoreClusterArgs.html">DatastoreClusterArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DatastoreClusterState.html">DatastoreClusterState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DatastoreClusterVmAntiAffinityRule.html">DatastoreClusterVmAntiAffinityRule</a></h4>
      <section><p>The <code>vsphere..DatastoreClusterVmAntiAffinityRule</code> resource can be used to
manage VM anti-affinity rules in a datastore cluster, either created by the
<code>vsphere..DatastoreCluster</code> resource or looked up
by the <code>vsphere..DatastoreCluster</code> data source.</p>
<p>This rule can be used to tell a set to virtual machines to run on different
datastores within a cluster, useful for preventing single points of failure in
application cluster scenarios. When configured, Storage DRS will make a best effort to
ensure that the virtual machines run on different datastores, or prevent any
operation that would keep that from happening, depending on the value of the
<code>mandatory</code> flag.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> Storage DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using System.Collections.Generic;
using System.Linq;
using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastoreCluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastoreCluster.InvokeAsync(new VSphere.GetDatastoreClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore-cluster1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm = new List&amp;lt;VSphere.VirtualMachine&gt;();
    for (var rangeIndex = 0; rangeIndex &amp;lt; 2; rangeIndex++)
    {
        var range = new { Value = rangeIndex };
        vm.Add(new VSphere.VirtualMachine($&amp;quot;vm-{range.Value}&amp;quot;, new VSphere.VirtualMachineArgs
        {
            DatastoreClusterId = datastoreCluster.Apply(datastoreCluster =&gt; datastoreCluster.Id),
            Disks = 
            {
                new VSphere.Inputs.VirtualMachineDiskArgs
                {
                    Label = &amp;quot;disk0&amp;quot;,
                    Size = 20,
                },
            },
            GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
            Memory = 2048,
            NetworkInterfaces = 
            {
                new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
                {
                    NetworkId = network.Apply(network =&gt; network.Id),
                },
            },
            NumCpus = 2,
            ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
        }));
    }
    var clusterVmAntiAffinityRule = new VSphere.DatastoreClusterVmAntiAffinityRule(&amp;quot;clusterVmAntiAffinityRule&amp;quot;, new VSphere.DatastoreClusterVmAntiAffinityRuleArgs
    {
        DatastoreClusterId = datastoreCluster.Apply(datastoreCluster =&gt; datastoreCluster.Id),
        VirtualMachineIds = vm.Select(__item =&gt; __item.Id).ToList(),
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.DatastoreClusterVmAntiAffinityRuleArgs.html">DatastoreClusterVmAntiAffinityRuleArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DatastoreClusterVmAntiAffinityRuleState.html">DatastoreClusterVmAntiAffinityRuleState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DistributedPortGroup.html">DistributedPortGroup</a></h4>
      <section><p>The <code>vsphere..DistributedPortGroup</code> resource can be used to manage vSphere
distributed virtual port groups. These port groups are connected to distributed
virtual switches, which can be managed by the
<code>vsphere..DistributedVirtualSwitch</code> resource.</p>
<p>Distributed port groups can be used as networks for virtual machines, allowing
VMs to use the networking supplied by a distributed virtual switch (DVS), with
a set of policies that apply to that individual newtork, if desired.</p>
<p>For an overview on vSphere networking concepts, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html">this
page</a>. For more information on vSphere DVS
portgroups, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-69933F6E-2442-46CF-AA17-1196CB9A0A09.html">this page</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<h3 id="overriding-dvs-policies">Overriding DVS policies</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dvs = new VSphere.DistributedVirtualSwitch(&amp;quot;dvs&amp;quot;, new VSphere.DistributedVirtualSwitchArgs
    {
        ActiveUplinks = 
        {
            &amp;quot;tfup1&amp;quot;,
        },
        DatacenterId = data.Vsphere_datacenter.Dc.Id,
        StandbyUplinks = 
        {
            &amp;quot;tfup2&amp;quot;,
        },
        Uplinks = 
        {
            &amp;quot;tfup1&amp;quot;,
            &amp;quot;tfup2&amp;quot;,
        },
    });
    var pg = new VSphere.DistributedPortGroup(&amp;quot;pg&amp;quot;, new VSphere.DistributedPortGroupArgs
    {
        ActiveUplinks = 
        {
            &amp;quot;tfup1&amp;quot;,
            &amp;quot;tfup2&amp;quot;,
        },
        DistributedVirtualSwitchUuid = dvs.Id,
        StandbyUplinks = {},
        VlanId = 1000,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.DistributedPortGroupArgs.html">DistributedPortGroupArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DistributedPortGroupState.html">DistributedPortGroupState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DistributedVirtualSwitch.html">DistributedVirtualSwitch</a></h4>
      <section><p>The <code>vsphere..DistributedVirtualSwitch</code> resource can be used to manage VMware
Distributed Virtual Switches.</p>
<p>An essential component of a distributed, scalable VMware datacenter, the
vSphere Distributed Virtual Switch (DVS) provides centralized management and
monitoring of the networking configuration of all the hosts that are associated
with the switch. In addition to adding port groups (see the
<code>vsphere..DistributedPortGroup</code> resource) that can
be used as networks for virtual machines, a DVS can be configured to perform
advanced high availability, traffic shaping, network monitoring, and more.</p>
<p>For an overview on vSphere networking concepts, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html">this
page</a>. For more information on vSphere DVS, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-375B45C7-684C-4C51-BA3C-70E48DFABF04.html">this
page</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<h3 id="uplink-name-and-count-control">Uplink name and count control</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dvs = new VSphere.DistributedVirtualSwitch(&amp;quot;dvs&amp;quot;, new VSphere.DistributedVirtualSwitchArgs
    {
        ActiveUplinks = 
        {
            &amp;quot;tfup1&amp;quot;,
        },
        DatacenterId = data.Vsphere_datacenter.Dc.Id,
        StandbyUplinks = 
        {
            &amp;quot;tfup2&amp;quot;,
        },
        Uplinks = 
        {
            &amp;quot;tfup1&amp;quot;,
            &amp;quot;tfup2&amp;quot;,
        },
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.DistributedVirtualSwitchArgs.html">DistributedVirtualSwitchArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DistributedVirtualSwitchState.html">DistributedVirtualSwitchState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DpmHostOverride.html">DpmHostOverride</a></h4>
      <section><p>The <code>vsphere..DpmHostOverride</code> resource can be used to add a DPM override to a
cluster for a particular host. This allows you to control the power management
settings for individual hosts in the cluster while leaving any unspecified ones
at the default power management settings.</p>
<p>For more information on DPM within vSphere clusters, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-5E5E349A-4644-4C9C-B434-1C0243EBDC80.html">this
page</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.DpmHostOverrideArgs.html">DpmHostOverrideArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DpmHostOverrideState.html">DpmHostOverrideState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DrsVmOverride.html">DrsVmOverride</a></h4>
      <section><p>The <code>vsphere..DrsVmOverride</code> resource can be used to add a DRS override to a
cluster for a specific virtual machine. With this resource, one can enable or
disable DRS and control the automation level for a single virtual machine
without affecting the rest of the cluster.</p>
<p>For more information on vSphere clusters and DRS, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-8ACF3502-5314-469F-8CC9-4A9BD5925BC2.html">this
page</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> vSphere DRS requires a vSphere Enterprise Plus license.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var host = dc.Apply(dc =&gt; Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;esxi1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm = new VSphere.VirtualMachine(&amp;quot;vm&amp;quot;, new VSphere.VirtualMachineArgs
    {
        DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
        Disks = 
        {
            new VSphere.Inputs.VirtualMachineDiskArgs
            {
                Label = &amp;quot;disk0&amp;quot;,
                Size = 20,
            },
        },
        GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
        HostSystemId = host.Apply(host =&gt; host.Id),
        Memory = 2048,
        NetworkInterfaces = 
        {
            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
            {
                NetworkId = network.Apply(network =&gt; network.Id),
            },
        },
        NumCpus = 2,
        ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
    });
    var drsVmOverride = new VSphere.DrsVmOverride(&amp;quot;drsVmOverride&amp;quot;, new VSphere.DrsVmOverrideArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        DrsEnabled = false,
        VirtualMachineId = vm.Id,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.DrsVmOverrideArgs.html">DrsVmOverrideArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.DrsVmOverrideState.html">DrsVmOverrideState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.File.html">File</a></h4>
      <section><p>The <code>vsphere..File</code> resource can be used to upload files (such as virtual disk
files) from the host machine that this provider is running on to a target
datastore.  The resource can also be used to copy files between datastores, or
from one location to another on the same datastore.</p>
<p>Updates to destination parameters such as <code>datacenter</code>, <code>datastore</code>, or
<code>destination_file</code> will move the managed file a new destination based on the
values of the new settings.  If any source parameter is changed, such as
<code>source_datastore</code>, <code>source_datacenter</code> or <code>source_file</code>), the resource will be
re-created. Depending on if destination parameters are being changed as well,
this may result in the destination file either being overwritten or deleted at
the old location.</p>
<h2 id="example-usage">Example Usage</h2>
<h3 id="uploading-a-file">Uploading a file</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var ubuntuDiskUpload = new VSphere.File(&amp;quot;ubuntuDiskUpload&amp;quot;, new VSphere.FileArgs
    {
        Datacenter = &amp;quot;my_datacenter&amp;quot;,
        Datastore = &amp;quot;local&amp;quot;,
        DestinationFile = &amp;quot;/my_path/disks/custom_ubuntu.vmdk&amp;quot;,
        SourceFile = &amp;quot;/home/ubuntu/my_disks/custom_ubuntu.vmdk&amp;quot;,
    });
}

}
</code></pre>
<h3 id="copying-a-file">Copying a file</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var ubuntuDiskCopy = new VSphere.File(&amp;quot;ubuntuDiskCopy&amp;quot;, new VSphere.FileArgs
    {
        Datacenter = &amp;quot;my_datacenter&amp;quot;,
        Datastore = &amp;quot;local&amp;quot;,
        DestinationFile = &amp;quot;/my_path/custom_ubuntu_id.vmdk&amp;quot;,
        SourceDatacenter = &amp;quot;my_datacenter&amp;quot;,
        SourceDatastore = &amp;quot;local&amp;quot;,
        SourceFile = &amp;quot;/my_path/disks/custom_ubuntu.vmdk&amp;quot;,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.FileArgs.html">FileArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.FileState.html">FileState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.Folder.html">Folder</a></h4>
      <section><p>The <code>vsphere..Folder</code> resource can be used to manage vSphere inventory folders.
The resource supports creating folders of the 5 major types - datacenter
folders, host and cluster folders, virtual machine folders, datastore folders,
and network folders.</p>
<p>Paths are always relative to the specific type of folder you are creating.
Subfolders are discovered by parsing the relative path specified in <code>path</code>, so
<code>foo/bar</code> will create a folder named <code>bar</code> in the parent folder <code>foo</code>, as long
as that folder exists.</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync());
    var folder = new VSphere.Folder(&amp;quot;folder&amp;quot;, new VSphere.FolderArgs
    {
        DatacenterId = dc.Apply(dc =&gt; dc.Id),
        Path = &amp;quot;test-folder&amp;quot;,
        Type = &amp;quot;vm&amp;quot;,
    });
}

}
</code></pre>
<h3 id="example-with-subfolders">Example with subfolders</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync());
    var parent = new VSphere.Folder(&amp;quot;parent&amp;quot;, new VSphere.FolderArgs
    {
        DatacenterId = dc.Apply(dc =&gt; dc.Id),
        Path = &amp;quot;test-parent&amp;quot;,
        Type = &amp;quot;vm&amp;quot;,
    });
    var folder = new VSphere.Folder(&amp;quot;folder&amp;quot;, new VSphere.FolderArgs
    {
        DatacenterId = dc.Apply(dc =&gt; dc.Id),
        Path = parent.Path.Apply(path =&gt; $&amp;quot;{path}/test-folder&amp;quot;),
        Type = &amp;quot;vm&amp;quot;,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.FolderArgs.html">FolderArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.FolderState.html">FolderState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetComputeCluster.html">GetComputeCluster</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetComputeClusterArgs.html">GetComputeClusterArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetComputeClusterResult.html">GetComputeClusterResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetContentLibrary.html">GetContentLibrary</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetContentLibraryArgs.html">GetContentLibraryArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetContentLibraryItem.html">GetContentLibraryItem</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetContentLibraryItemArgs.html">GetContentLibraryItemArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetContentLibraryItemResult.html">GetContentLibraryItemResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetContentLibraryResult.html">GetContentLibraryResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetCustomAttribute.html">GetCustomAttribute</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetCustomAttributeArgs.html">GetCustomAttributeArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetCustomAttributeResult.html">GetCustomAttributeResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatacenter.html">GetDatacenter</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatacenterArgs.html">GetDatacenterArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatacenterResult.html">GetDatacenterResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatastore.html">GetDatastore</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatastoreArgs.html">GetDatastoreArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatastoreCluster.html">GetDatastoreCluster</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatastoreClusterArgs.html">GetDatastoreClusterArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatastoreClusterResult.html">GetDatastoreClusterResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDatastoreResult.html">GetDatastoreResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDistributedVirtualSwitch.html">GetDistributedVirtualSwitch</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDistributedVirtualSwitchArgs.html">GetDistributedVirtualSwitchArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetDistributedVirtualSwitchResult.html">GetDistributedVirtualSwitchResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetFolder.html">GetFolder</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetFolderArgs.html">GetFolderArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetFolderResult.html">GetFolderResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetHost.html">GetHost</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetHostArgs.html">GetHostArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetHostResult.html">GetHostResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetNetwork.html">GetNetwork</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetNetworkArgs.html">GetNetworkArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetNetworkResult.html">GetNetworkResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetPolicy.html">GetPolicy</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetPolicyArgs.html">GetPolicyArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetPolicyResult.html">GetPolicyResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetResourcePool.html">GetResourcePool</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetResourcePoolArgs.html">GetResourcePoolArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetResourcePoolResult.html">GetResourcePoolResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetTag.html">GetTag</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetTagArgs.html">GetTagArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetTagCategory.html">GetTagCategory</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetTagCategoryArgs.html">GetTagCategoryArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetTagCategoryResult.html">GetTagCategoryResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetTagResult.html">GetTagResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVappContainer.html">GetVappContainer</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVappContainerArgs.html">GetVappContainerArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVappContainerResult.html">GetVappContainerResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVirtualMachine.html">GetVirtualMachine</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVirtualMachineArgs.html">GetVirtualMachineArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVirtualMachineResult.html">GetVirtualMachineResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVmfsDisks.html">GetVmfsDisks</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVmfsDisksArgs.html">GetVmfsDisksArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.GetVmfsDisksResult.html">GetVmfsDisksResult</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HaVmOverride.html">HaVmOverride</a></h4>
      <section><p>The <code>vsphere..HaVmOverride</code> resource can be used to add an override for
vSphere HA settings on a cluster for a specific virtual machine. With this
resource, one can control specific HA settings so that they are different than
the cluster default, accommodating the needs of that specific virtual machine,
while not affecting the rest of the cluster.</p>
<p>For more information on vSphere HA, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.avail.doc/GUID-5432CA24-14F1-44E3-87FB-61D937831CF6.html">this page</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> This resource requires vCenter and is not available on direct ESXi
connections.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var cluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var vm = new VSphere.VirtualMachine(&amp;quot;vm&amp;quot;, new VSphere.VirtualMachineArgs
    {
        DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
        Disks = 
        {
            new VSphere.Inputs.VirtualMachineDiskArgs
            {
                Label = &amp;quot;disk0&amp;quot;,
                Size = 20,
            },
        },
        GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
        Memory = 2048,
        NetworkInterfaces = 
        {
            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
            {
                NetworkId = network.Apply(network =&gt; network.Id),
            },
        },
        NumCpus = 2,
        ResourcePoolId = cluster.Apply(cluster =&gt; cluster.ResourcePoolId),
    });
    var haVmOverride = new VSphere.HaVmOverride(&amp;quot;haVmOverride&amp;quot;, new VSphere.HaVmOverrideArgs
    {
        ComputeClusterId = cluster.Apply(cluster =&gt; cluster.Id),
        HaVmRestartPriority = &amp;quot;highest&amp;quot;,
        VirtualMachineId = vm.Id,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.HaVmOverrideArgs.html">HaVmOverrideArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HaVmOverrideState.html">HaVmOverrideState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.Host.html">Host</a></h4>
      <section><p>Provides a VMware vSphere host resource. This represents an ESXi host that
can be used either as part of a Compute Cluster or Standalone.</p>
<h2 id="example-usage">Example Usage</h2>
<h3 id="create-a-standalone-host">Create a standalone host</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;my-datacenter&amp;quot;,
    }));
    var h1 = new VSphere.Host(&amp;quot;h1&amp;quot;, new VSphere.HostArgs
    {
        Hostname = &amp;quot;10.10.10.1&amp;quot;,
        Username = &amp;quot;root&amp;quot;,
        Password = &amp;quot;password&amp;quot;,
        License = &amp;quot;00000-00000-00000-00000i-00000&amp;quot;,
        Datacenter = dc.Apply(dc =&gt; dc.Id),
    });
}

}
</code></pre>
<h3 id="create-host-in-a-compute-cluster">Create host in a compute cluster</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;TfDatacenter&amp;quot;,
    }));
    var c1 = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        Name = &amp;quot;DC0_C0&amp;quot;,
        DatacenterId = dc.Id,
    })));
    var h1 = new VSphere.Host(&amp;quot;h1&amp;quot;, new VSphere.HostArgs
    {
        Hostname = &amp;quot;10.10.10.1&amp;quot;,
        Username = &amp;quot;root&amp;quot;,
        Password = &amp;quot;password&amp;quot;,
        License = &amp;quot;00000-00000-00000-00000i-00000&amp;quot;,
        Cluster = c1.Apply(c1 =&gt; c1.Id),
    });
}

}
</code></pre>
<h2 id="importing">Importing</h2>
<p>An existing host can be <a href="/docs/import/index.html">imported</a> into this resource
via supplying the host's ID. An example is below:</p>
<pre><code class="lang-csharp">using Pulumi;

class MyStack : Stack
{
public MyStack()
{
}

}
</code></pre>
<p>The above would import the host with ID <code>host-123</code>.</p>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.HostArgs.html">HostArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HostPortGroup.html">HostPortGroup</a></h4>
      <section><p>The <code>vsphere..HostPortGroup</code> resource can be used to manage vSphere standard
port groups on an ESXi host. These port groups are connected to standard
virtual switches, which can be managed by the
<code>vsphere..HostVirtualSwitch</code> resource.</p>
<p>For an overview on vSphere networking concepts, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.networking.doc/GUID-2B11DBB8-CB3C-4AFF-8885-EFEA0FC562F4.html">this page</a>.</p>
<h2 id="example-usage">Example Usage</h2>
<h3 id="create-a-virtual-switch-and-bind-a-port-group-to-it">Create a virtual switch and bind a port group to it</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var esxiHost = datacenter.Apply(datacenter =&gt; Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs
    {
        DatacenterId = datacenter.Id,
        Name = &amp;quot;esxi1&amp;quot;,
    })));
    var @switch = new VSphere.HostVirtualSwitch(&amp;quot;switch&amp;quot;, new VSphere.HostVirtualSwitchArgs
    {
        ActiveNics = 
        {
            &amp;quot;vmnic0&amp;quot;,
        },
        HostSystemId = esxiHost.Apply(esxiHost =&gt; esxiHost.Id),
        NetworkAdapters = 
        {
            &amp;quot;vmnic0&amp;quot;,
            &amp;quot;vmnic1&amp;quot;,
        },
        StandbyNics = 
        {
            &amp;quot;vmnic1&amp;quot;,
        },
    });
    var pg = new VSphere.HostPortGroup(&amp;quot;pg&amp;quot;, new VSphere.HostPortGroupArgs
    {
        HostSystemId = esxiHost.Apply(esxiHost =&gt; esxiHost.Id),
        VirtualSwitchName = @switch.Name,
    });
}

}
</code></pre>
<h3 id="create-a-port-group-with-vlan-set-and-some-overrides">Create a port group with VLAN set and some overrides</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var esxiHost = datacenter.Apply(datacenter =&gt; Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs
    {
        DatacenterId = datacenter.Id,
        Name = &amp;quot;esxi1&amp;quot;,
    })));
    var @switch = new VSphere.HostVirtualSwitch(&amp;quot;switch&amp;quot;, new VSphere.HostVirtualSwitchArgs
    {
        ActiveNics = 
        {
            &amp;quot;vmnic0&amp;quot;,
        },
        HostSystemId = esxiHost.Apply(esxiHost =&gt; esxiHost.Id),
        NetworkAdapters = 
        {
            &amp;quot;vmnic0&amp;quot;,
            &amp;quot;vmnic1&amp;quot;,
        },
        StandbyNics = 
        {
            &amp;quot;vmnic1&amp;quot;,
        },
    });
    var pg = new VSphere.HostPortGroup(&amp;quot;pg&amp;quot;, new VSphere.HostPortGroupArgs
    {
        AllowPromiscuous = true,
        HostSystemId = esxiHost.Apply(esxiHost =&gt; esxiHost.Id),
        VirtualSwitchName = @switch.Name,
        VlanId = 4095,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.HostPortGroupArgs.html">HostPortGroupArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HostPortGroupState.html">HostPortGroupState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HostState.html">HostState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HostVirtualSwitch.html">HostVirtualSwitch</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HostVirtualSwitchArgs.html">HostVirtualSwitchArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.HostVirtualSwitchState.html">HostVirtualSwitchState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.License.html">License</a></h4>
      <section><p>Provides a VMware vSphere license resource. This can be used to add and remove license keys.</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var licenseKey = new VSphere.License(&amp;quot;licenseKey&amp;quot;, new VSphere.LicenseArgs
    {
        Labels = 
        {
            { &amp;quot;VpxClientLicenseLabel&amp;quot;, &amp;quot;Hello World&amp;quot; },
            { &amp;quot;Workflow&amp;quot;, &amp;quot;Hello World&amp;quot; },
        },
        LicenseKey = &amp;quot;452CQ-2EK54-K8742-00000-00000&amp;quot;,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.LicenseArgs.html">LicenseArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.LicenseState.html">LicenseState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.NasDatastore.html">NasDatastore</a></h4>
      <section><p>The <code>vsphere..NasDatastore</code> resource can be used to create and manage NAS
datastores on an ESXi host or a set of hosts. The resource supports mounting
NFS v3 and v4.1 shares to be used as datastores.</p>
<blockquote>
<p><strong>NOTE:</strong> Unlike <code>vsphere..VmfsDatastore</code>, a NAS
datastore is only mounted on the hosts you choose to mount it on. To mount on
multiple hosts, you must specify each host that you want to add in the
<code>host_system_ids</code> argument.</p>
</blockquote>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.NasDatastoreArgs.html">NasDatastoreArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.NasDatastoreState.html">NasDatastoreState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.Provider.html">Provider</a></h4>
      <section><p>The provider type for the vsphere package. By default, resources use package-wide configuration
settings, however an explicit <code>Provider</code> instance may be created and passed during resource
construction to achieve fine-grained programmatic control over provider settings. See the
<a href="https://www.pulumi.com/docs/reference/programming-model/#providers">documentation</a> for more information.</p>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ProviderArgs.html">ProviderArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ResourcePool.html">ResourcePool</a></h4>
      <section><p>The <code>vsphere..ResourcePool</code> resource can be used to create and manage
resource pools in standalone hosts or on compute clusters.</p>
<p>For more information on vSphere resource pools, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-60077B40-66FF-4625-934A-641703ED7601.html">this
page</a>.</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var config = new Config();
    var datacenter = config.Get(&amp;quot;datacenter&amp;quot;) ?? &amp;quot;dc1&amp;quot;;
    var cluster = config.Get(&amp;quot;cluster&amp;quot;) ?? &amp;quot;cluster1&amp;quot;;
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = datacenter,
    }));
    var computeCluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = cluster,
    })));
    var resourcePool = new VSphere.ResourcePool(&amp;quot;resourcePool&amp;quot;, new VSphere.ResourcePoolArgs
    {
        ParentResourcePoolId = computeCluster.Apply(computeCluster =&gt; computeCluster.ResourcePoolId),
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.ResourcePoolArgs.html">ResourcePoolArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.ResourcePoolState.html">ResourcePoolState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.StorageDrsVmOverride.html">StorageDrsVmOverride</a></h4>
      <section><p>The <code>vsphere..StorageDrsVmOverride</code> resource can be used to add a Storage DRS
override to a datastore cluster for a specific virtual machine. With this
resource, one can enable or disable Storage DRS, and control the automation
level and disk affinity for a single virtual machine without affecting the rest
of the datastore cluster.</p>
<p>For more information on vSphere datastore clusters and Storage DRS, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.resmgmt.doc/GUID-598DF695-107E-406B-9C95-0AF961FC227A.html">this
page</a>.</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var datastoreCluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastoreCluster.InvokeAsync(new VSphere.GetDatastoreClusterArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore-cluster1&amp;quot;,
    })));
    var memberDatastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore-cluster1-member1&amp;quot;,
    })));
    var pool = dc.Apply(dc =&gt; Output.Create(VSphere.GetResourcePool.InvokeAsync(new VSphere.GetResourcePoolArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;cluster1/Resources&amp;quot;,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;public&amp;quot;,
    })));
    var vm = new VSphere.VirtualMachine(&amp;quot;vm&amp;quot;, new VSphere.VirtualMachineArgs
    {
        DatastoreId = memberDatastore.Apply(memberDatastore =&gt; memberDatastore.Id),
        Disks = 
        {
            new VSphere.Inputs.VirtualMachineDiskArgs
            {
                Label = &amp;quot;disk0&amp;quot;,
                Size = 20,
            },
        },
        GuestId = &amp;quot;other3xLinux64Guest&amp;quot;,
        Memory = 1024,
        NetworkInterfaces = 
        {
            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
            {
                NetworkId = network.Apply(network =&gt; network.Id),
            },
        },
        NumCpus = 2,
        ResourcePoolId = pool.Apply(pool =&gt; pool.Id),
    });
    var drsVmOverride = new VSphere.StorageDrsVmOverride(&amp;quot;drsVmOverride&amp;quot;, new VSphere.StorageDrsVmOverrideArgs
    {
        DatastoreClusterId = datastoreCluster.Apply(datastoreCluster =&gt; datastoreCluster.Id),
        SdrsEnabled = false,
        VirtualMachineId = vm.Id,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.StorageDrsVmOverrideArgs.html">StorageDrsVmOverrideArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.StorageDrsVmOverrideState.html">StorageDrsVmOverrideState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.Tag.html">Tag</a></h4>
      <section><p>The <code>vsphere..Tag</code> resource can be used to create and manage tags, which allow
you to attach metadata to objects in the vSphere inventory to make these
objects more sortable and searchable.</p>
<p>For more information about tags, click <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vcenterhost.doc/GUID-E8E854DD-AA97-4E0C-8419-CE84F93C4058.html">here</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> Tagging support is unsupported on direct ESXi connections and
requires vCenter 6.0 or higher.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var category = new VSphere.TagCategory(&amp;quot;category&amp;quot;, new VSphere.TagCategoryArgs
    {
        AssociableTypes = 
        {
            &amp;quot;VirtualMachine&amp;quot;,
            &amp;quot;Datastore&amp;quot;,
        },
        Cardinality = &amp;quot;SINGLE&amp;quot;,
        Description = &amp;quot;Managed by Pulumi&amp;quot;,
    });
    var tag = new VSphere.Tag(&amp;quot;tag&amp;quot;, new VSphere.TagArgs
    {
        CategoryId = category.Id,
        Description = &amp;quot;Managed by Pulumi&amp;quot;,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.TagArgs.html">TagArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.TagCategory.html">TagCategory</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.TagCategoryArgs.html">TagCategoryArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.TagCategoryState.html">TagCategoryState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.TagState.html">TagState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VappContainer.html">VappContainer</a></h4>
      <section><p>The <code>vsphere..VappContainer</code> resource can be used to create and manage
vApps.</p>
<p>For more information on vSphere vApps, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-2A95EBB8-1779-40FA-B4FB-4D0845750879.html">this
page</a>.</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var config = new Config();
    var datacenter = config.Get(&amp;quot;datacenter&amp;quot;) ?? &amp;quot;dc1&amp;quot;;
    var cluster = config.Get(&amp;quot;cluster&amp;quot;) ?? &amp;quot;cluster1&amp;quot;;
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = datacenter,
    }));
    var computeCluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = cluster,
    })));
    var vappContainer = new VSphere.VappContainer(&amp;quot;vappContainer&amp;quot;, new VSphere.VappContainerArgs
    {
        ParentResourcePoolId = computeCluster.Apply(computeCluster =&gt; computeCluster.Id),
    });
}

}
</code></pre>
<h3 id="example-with-virtual-machine">Example with virtual machine</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var config = new Config();
    var datacenter = config.Get(&amp;quot;datacenter&amp;quot;) ?? &amp;quot;dc1&amp;quot;;
    var cluster = config.Get(&amp;quot;cluster&amp;quot;) ?? &amp;quot;cluster1&amp;quot;;
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = datacenter,
    }));
    var computeCluster = dc.Apply(dc =&gt; Output.Create(VSphere.GetComputeCluster.InvokeAsync(new VSphere.GetComputeClusterArgs
    {
        DatacenterId = dc.Id,
        Name = cluster,
    })));
    var network = dc.Apply(dc =&gt; Output.Create(VSphere.GetNetwork.InvokeAsync(new VSphere.GetNetworkArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;network1&amp;quot;,
    })));
    var datastore = dc.Apply(dc =&gt; Output.Create(VSphere.GetDatastore.InvokeAsync(new VSphere.GetDatastoreArgs
    {
        DatacenterId = dc.Id,
        Name = &amp;quot;datastore1&amp;quot;,
    })));
    var vappContainer = new VSphere.VappContainer(&amp;quot;vappContainer&amp;quot;, new VSphere.VappContainerArgs
    {
        ParentResourcePoolId = computeCluster.Apply(computeCluster =&gt; computeCluster.Id),
    });
    var vm = new VSphere.VirtualMachine(&amp;quot;vm&amp;quot;, new VSphere.VirtualMachineArgs
    {
        DatastoreId = datastore.Apply(datastore =&gt; datastore.Id),
        Disks = 
        {
            new VSphere.Inputs.VirtualMachineDiskArgs
            {
                Label = &amp;quot;disk0&amp;quot;,
                Size = 1,
            },
        },
        GuestId = &amp;quot;ubuntu64Guest&amp;quot;,
        Memory = 1024,
        NetworkInterfaces = 
        {
            new VSphere.Inputs.VirtualMachineNetworkInterfaceArgs
            {
                NetworkId = network.Apply(network =&gt; network.Id),
            },
        },
        NumCpus = 2,
        ResourcePoolId = vappContainer.Id,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.VappContainerArgs.html">VappContainerArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VappContainerState.html">VappContainerState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VappEntity.html">VappEntity</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VappEntityArgs.html">VappEntityArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VappEntityState.html">VappEntityState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualDisk.html">VirtualDisk</a></h4>
      <section><p>The <code>vsphere..VirtualDisk</code> resource can be used to create virtual disks outside
of any given <code>vsphere..VirtualMachine</code>
resource. These disks can be attached to a virtual machine by creating a disk
block with the <code>attach</code> parameter.</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var myDisk = new VSphere.VirtualDisk(&amp;quot;myDisk&amp;quot;, new VSphere.VirtualDiskArgs
    {
        Datacenter = &amp;quot;Datacenter&amp;quot;,
        Datastore = &amp;quot;local&amp;quot;,
        Size = 2,
        Type = &amp;quot;thin&amp;quot;,
        VmdkPath = &amp;quot;myDisk.vmdk&amp;quot;,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualDiskArgs.html">VirtualDiskArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualDiskState.html">VirtualDiskState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualMachine.html">VirtualMachine</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualMachineArgs.html">VirtualMachineArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualMachineSnapshot.html">VirtualMachineSnapshot</a></h4>
      <section><p>The <code>vsphere..VirtualMachineSnapshot</code> resource can be used to manage snapshots
for a virtual machine.</p>
<p>For more information on managing snapshots and how they work in VMware, see
<a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-CA948C69-7F58-4519-AEB1-739545EA94E5.html">here</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> A snapshot in VMware differs from traditional disk snapshots, and
can contain the actual running state of the virtual machine, data for all disks
that have not been set to be independent from the snapshot (including ones that
have been attached via the <code>attach</code>
parameter to the <code>vsphere..VirtualMachine</code> <code>disk</code> block), and even the
configuration of the virtual machine at the time of the snapshot. Virtual
machine, disk activity, and configuration changes post-snapshot are not
included in the original state. Use this resource with care! Neither VMware nor
HashiCorp recommends retaining snapshots for a extended period of time and does
NOT recommend using them as as backup feature. For more information on the
limitation of virtual machine snapshots, see <a href="https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-53F65726-A23B-4CF0-A7D5-48E584B88613.html">here</a>.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var demo1 = new VSphere.VirtualMachineSnapshot(&amp;quot;demo1&amp;quot;, new VSphere.VirtualMachineSnapshotArgs
    {
        Consolidate = &amp;quot;true&amp;quot;,
        Description = &amp;quot;This is Demo Snapshot&amp;quot;,
        Memory = &amp;quot;true&amp;quot;,
        Quiesce = &amp;quot;true&amp;quot;,
        RemoveChildren = &amp;quot;false&amp;quot;,
        SnapshotName = &amp;quot;Snapshot Name&amp;quot;,
        VirtualMachineUuid = &amp;quot;9aac5551-a351-4158-8c5c-15a71e8ec5c9&amp;quot;,
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualMachineSnapshotArgs.html">VirtualMachineSnapshotArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualMachineSnapshotState.html">VirtualMachineSnapshotState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VirtualMachineState.html">VirtualMachineState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VmfsDatastore.html">VmfsDatastore</a></h4>
      <section><p>The <code>vsphere..VmfsDatastore</code> resource can be used to create and manage VMFS
datastores on an ESXi host or a set of hosts. The resource supports using any
SCSI device that can generally be used in a datastore, such as local disks, or
disks presented to a host or multiple hosts over Fibre Channel or iSCSI.
Devices can be specified manually, or discovered using the
<a href="/docs/providers/vsphere/d/vmfs_disks.html"><code>vsphere..getVmfsDisks</code></a> data source.</p>
<h2 id="auto-mounting-of-datastores-within-vcenter">Auto-Mounting of Datastores Within vCenter</h2>
<p>Note that the current behaviour of this resource will auto-mount any created
datastores to any other host within vCenter that has access to the same disk.</p>
<p>Example: You want to create a datastore with a iSCSI LUN that is visible on 3
hosts in a single vSphere cluster (<code>esxi1</code>, <code>esxi2</code> and <code>esxi3</code>). When you
create the datastore on <code>esxi1</code>, the datastore will be automatically mounted on
<code>esxi2</code> and <code>esxi3</code>, without the need to configure the resource on either of
those two hosts.</p>
<p>Future versions of this resource may allow you to control the hosts that a
datastore is mounted to, but currently, this automatic behaviour cannot be
changed, so keep this in mind when writing your configurations and deploying
your disks.</p>
<h2 id="increasing-datastore-size">Increasing Datastore Size</h2>
<p>To increase the size of a datastore, you must add additional disks to the
<code>disks</code> attribute. Expanding the size of a datastore by increasing the size of
an already provisioned disk is currently not supported (but may be in future
versions of this resource).</p>
<blockquote>
<p><strong>NOTE:</strong> You cannot decrease the size of a datastore. If the resource
detects disks removed from the configuration, the provider will give an error.</p>
</blockquote>
<h2 id="example-usage">Example Usage</h2>
<h3 id="addition-of-local-disks-on-a-single-host">Addition of local disks on a single host</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync());
    var esxiHost = datacenter.Apply(datacenter =&gt; Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs
    {
        DatacenterId = datacenter.Id,
    })));
    var datastore = new VSphere.VmfsDatastore(&amp;quot;datastore&amp;quot;, new VSphere.VmfsDatastoreArgs
    {
        Disks = 
        {
            &amp;quot;mpx.vmhba1:C0:T1:L0&amp;quot;,
            &amp;quot;mpx.vmhba1:C0:T2:L0&amp;quot;,
            &amp;quot;mpx.vmhba1:C0:T2:L0&amp;quot;,
        },
        HostSystemId = esxiHost.Apply(esxiHost =&gt; esxiHost.Id),
    });
}

}
</code></pre>
<h3 id="auto-detection-of-disks-via-vspheregetvmfsdisks">Auto-detection of disks via <code>vsphere..getVmfsDisks</code></h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var datacenter = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;dc1&amp;quot;,
    }));
    var esxiHost = datacenter.Apply(datacenter =&gt; Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs
    {
        DatacenterId = datacenter.Id,
        Name = &amp;quot;esxi1&amp;quot;,
    })));
    var available = esxiHost.Apply(esxiHost =&gt; Output.Create(VSphere.GetVmfsDisks.InvokeAsync(new VSphere.GetVmfsDisksArgs
    {
        Filter = &amp;quot;naa.60a98000&amp;quot;,
        HostSystemId = esxiHost.Id,
        Rescan = true,
    })));
    var datastore = new VSphere.VmfsDatastore(&amp;quot;datastore&amp;quot;, new VSphere.VmfsDatastoreArgs
    {
        Disks = available.Apply(available =&gt; available.Disks),
        Folder = &amp;quot;datastore-folder&amp;quot;,
        HostSystemId = esxiHost.Apply(esxiHost =&gt; esxiHost.Id),
    });
}

}
</code></pre>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.VmfsDatastoreArgs.html">VmfsDatastoreArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VmfsDatastoreState.html">VmfsDatastoreState</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.Vnic.html">Vnic</a></h4>
      <section><p>Provides a VMware vSphere vnic resource.</p>
<h2 id="example-usages">Example Usages</h2>
<h3 id="create-a-vnic-attached-to-a-portgroup-using-the-default-tcpip-stack">Create a vnic attached to a portgroup using the default TCP/IP stack</h3>
<pre><code class="lang-csharp">using Pulumi;
using VSphere = Pulumi.VSphere;

class MyStack : Stack
{
public MyStack()
{
    var dc = Output.Create(VSphere.GetDatacenter.InvokeAsync(new VSphere.GetDatacenterArgs
    {
        Name = &amp;quot;mydc&amp;quot;,
    }));
    var h1 = dc.Apply(dc =&gt; Output.Create(VSphere.GetHost.InvokeAsync(new VSphere.GetHostArgs
    {
        Name = &amp;quot;esxi1.host.test&amp;quot;,
        DatacenterId = dc.Id,
    })));
    var hvs1 = new VSphere.HostVirtualSwitch(&amp;quot;hvs1&amp;quot;, new VSphere.HostVirtualSwitchArgs
    {
        HostSystemId = h1.Apply(h1 =&gt; h1.Id),
        NetworkAdapters = 
        {
            &amp;quot;vmnic3&amp;quot;,
            &amp;quot;vmnic4&amp;quot;,
        },
        ActiveNics = 
        {
            &amp;quot;vmnic3&amp;quot;,
        },
        StandbyNics = 
        {
            &amp;quot;vmnic4&amp;quot;,
        },
    });
    var p1 = new VSphere.HostPortGroup(&amp;quot;p1&amp;quot;, new VSphere.HostPortGroupArgs
    {
        VirtualSwitchName = hvs1.Name,
        HostSystemId = h1.Apply(h1 =&gt; h1.Id),
    });
    var v1 = new VSphere.Vnic(&amp;quot;v1&amp;quot;, new VSphere.VnicArgs
    {
        Host = h1.Apply(h1 =&gt; h1.Id),
        Portgroup = p1.Name,
        Ipv4 = new VSphere.Inputs.VnicIpv4Args
        {
            Dhcp = true,
        },
    });
}

}
</code></pre>
<h2 id="importing">Importing</h2>
<p>An existing vNic can be <a href="/docs/import/index.html">imported</a> into this resource
via supplying the vNic's ID. An example is below:</p>
<pre><code class="lang-csharp">using Pulumi;

class MyStack : Stack
{
public MyStack()
{
}

}
</code></pre>
<p>The above would import the the vnic <code>vmk2</code> from host with ID <code>host-123</code>.</p>
</section>
      <h4><a class="xref" href="Pulumi.VSphere.VnicArgs.html">VnicArgs</a></h4>
      <section></section>
      <h4><a class="xref" href="Pulumi.VSphere.VnicState.html">VnicState</a></h4>
      <section></section>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright 2016-2020, Pulumi Corporation.
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
